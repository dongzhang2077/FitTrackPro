package com.domcheung.fittrackpro.presentation.plan_builder

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.domcheung.fittrackpro.data.model.PlannedExercise
import com.domcheung.fittrackpro.data.model.PlannedSet
import com.domcheung.fittrackpro.data.model.WorkoutPlan
import com.domcheung.fittrackpro.data.repository.AuthRepository
import com.domcheung.fittrackpro.domain.usecase.CreateWorkoutPlanUseCase
import com.domcheung.fittrackpro.domain.usecase.GetExercisesByIdsUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel for the Plan Builder screen.
 * Manages the state and logic for creating and editing a workout plan.
 */
@HiltViewModel
class PlanBuilderViewModel @Inject constructor(
    private val createWorkoutPlanUseCase: CreateWorkoutPlanUseCase,
    private val getExercisesByIdsUseCase: GetExercisesByIdsUseCase,
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(PlanBuilderState())
    val uiState: StateFlow<PlanBuilderState> = _uiState

    /**
     * Called when exercises are selected from the library.
     * It fetches the full Exercise details and converts them into PlannedExercise objects.
     * @param selectedIds A set of IDs for the exercises chosen by the user.
     */
    fun addExercisesByIds(selectedIds: Set<Int>) {
        viewModelScope.launch {
            if (selectedIds.isEmpty()) return@launch

            val existingExerciseIds = _uiState.value.exercises.map { it.exerciseId }.toSet()
            // Filter out IDs that are already in the plan to avoid duplicates
            val newIds = selectedIds.filter { it !in existingExerciseIds }
            if (newIds.isEmpty()) return@launch

            // Fetch the full exercise data from the repository
            val exercisesToAdd = getExercisesByIdsUseCase(newIds.toList())

            val newPlannedExercises = exercisesToAdd.map { exercise ->
                PlannedExercise(
                    exerciseId = exercise.id,
                    exerciseName = exercise.name,
                    orderIndex = _uiState.value.exercises.size + 1,
                    // Add one default set
                    sets = listOf(PlannedSet(setNumber = 1, targetWeight = 20f, targetReps = 10))
                )
            }

            _uiState.update {
                it.copy(exercises = it.exercises + newPlannedExercises)
            }
        }
    }

    /**
     * The main function to save the newly created workout plan.
     */
    fun savePlan() {
        viewModelScope.launch {
            val state = _uiState.value
            val userId = authRepository.getCurrentUser()?.uid

            // Basic validation
            if (state.planName.isBlank()) {
                _uiState.update { it.copy(errorMessage = "Plan name cannot be empty.") }
                return@launch
            }
            if (state.exercises.isEmpty()) {
                _uiState.update { it.copy(errorMessage = "Plan must contain at least one exercise.") }
                return@launch
            }
            if (userId.isNullOrBlank()) {
                _uiState.update { it.copy(errorMessage = "User not logged in.") }
                return@launch
            }

            _uiState.update { it.copy(isLoading = true) }

            val newPlan = WorkoutPlan(
                id = "", // ID will be generated by the repository
                name = state.planName,
                description = state.description,
                exercises = state.exercises,
                createdBy = userId,
                isTemplate = false // User-created plans are not templates by default
            )

            val result = createWorkoutPlanUseCase(newPlan)
            result.fold(
                onSuccess = {
                    _uiState.update { it.copy(isLoading = false, isPlanSaved = true) }
                },
                onFailure = { exception ->
                    _uiState.update { it.copy(isLoading = false, errorMessage = exception.message) }
                }
            )
        }
    }

    /**
     * Clears an error message after it has been shown.
     */
    fun clearErrorMessage() {
        _uiState.update { it.copy(errorMessage = null) }
    }


    /**
     * Called when the plan name is changed by the user in the text field.
     */
    fun onPlanNameChanged(newName: String) {
        _uiState.update { it.copy(planName = newName) }
    }

    /**
     * Toggles the UI between displaying the plan name and editing it.
     */
    fun onToggleEditName(isEditing: Boolean) {
        _uiState.update { it.copy(isEditingName = isEditing) }
    }

    // Add these new functions inside your PlanBuilderViewModel class

    /**
     * Adds a new exercise to the current plan.
     * In a real scenario, this would be called from the Exercise Library screen.
     * For now, we'll use it for testing.
     * @param exercise The exercise to add.
     */
    fun addExercise(exercise: com.domcheung.fittrackpro.data.model.Exercise) {
        val newPlannedExercise = com.domcheung.fittrackpro.data.model.PlannedExercise(
            exerciseId = exercise.id,
            exerciseName = exercise.name,
            orderIndex = _uiState.value.exercises.size,
            // Add one default set when a new exercise is added.
            sets = listOf(com.domcheung.fittrackpro.data.model.PlannedSet(setNumber = 1, targetWeight = 20f, targetReps = 10))
        )
        _uiState.update {
            it.copy(exercises = it.exercises + newPlannedExercise)
        }
    }

    /**
     * Removes an exercise from the plan based on its index in the list.
     * @param index The index of the exercise to remove.
     */
    fun removeExercise(index: Int) {
        _uiState.update {
            val updatedExercises = it.exercises.toMutableList().apply {
                removeAt(index)
            }
            it.copy(exercises = updatedExercises)
        }
    }

    fun removeExerciseById(exerciseId: Int) {
        _uiState.update {
            it.copy(exercises = it.exercises.filterNot { exercise -> exercise.exerciseId == exerciseId })
        }
    }

    /**
     * Adds a new set to a specific exercise in the plan.
     * It copies the details from the last existing set.
     * @param exerciseIndex The index of the exercise to modify.
     */
    fun addSetToExercise(exerciseIndex: Int) {
        _uiState.update {
            val exercises = it.exercises.toMutableList()
            val exercise = exercises.getOrNull(exerciseIndex) ?: return@update it

            val sets = exercise.sets.toMutableList()
            val lastSet = sets.lastOrNull() ?: com.domcheung.fittrackpro.data.model.PlannedSet(setNumber = 0, targetWeight = 20f, targetReps = 10)

            // Create a new set by copying the last one.
            sets.add(lastSet.copy(setNumber = sets.size + 1))

            exercises[exerciseIndex] = exercise.copy(sets = sets)
            it.copy(exercises = exercises)
        }
    }

    /**
     * Removes the last set from a specific exercise.
     * @param exerciseIndex The index of the exercise to modify.
     */
    fun removeSetFromExercise(exerciseIndex: Int) {
        _uiState.update {
            val exercises = it.exercises.toMutableList()
            val exercise = exercises.getOrNull(exerciseIndex) ?: return@update it

            // Only remove if there is more than one set.
            if (exercise.sets.size > 1) {
                val sets = exercise.sets.toMutableList()
                sets.removeAt(sets.lastIndex)
                exercises[exerciseIndex] = exercise.copy(sets = sets)
                it.copy(exercises = exercises)
            } else {
                it // Return original state if only one set is left.
            }
        }
    }

    /**
     * Updates a specific set's details for a given exercise.
     * @param exerciseIndex The index of the exercise.
     * @param setIndex The index of the set within the exercise.
     * @param updatedSet The new data for the set.
     */
    fun updateSet(exerciseIndex: Int, setIndex: Int, updatedSet: com.domcheung.fittrackpro.data.model.PlannedSet) {
        _uiState.update {
            val exercises = it.exercises.toMutableList()
            val exercise = exercises.getOrNull(exerciseIndex) ?: return@update it

            val sets = exercise.sets.toMutableList()
            if (sets.getOrNull(setIndex) != null) {
                sets[setIndex] = updatedSet
                exercises[exerciseIndex] = exercise.copy(sets = sets)
                it.copy(exercises = exercises)
            } else {
                it
            }
        }
    }

    fun onExerciseClicked(exerciseId: Int) {
        _uiState.update {
            if (it.expandedExerciseId == exerciseId) {
                it.copy(expandedExerciseId = null)
            } else {
                it.copy(expandedExerciseId = exerciseId)
            }
        }
    }
}
